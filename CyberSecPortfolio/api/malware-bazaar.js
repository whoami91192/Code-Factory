const fetch = require('node-fetch');

module.exports = async (req, res) => {
  // Enable CORS
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  try {
    // Try different MalwareBazaar API endpoints
    const endpoints = [
      'https://bazaar.abuse.ch/export/csv/recent/',
      'https://bazaar.abuse.ch/export/csv/',
      'https://bazaar.abuse.ch/export/txt/recent/',
      'https://bazaar.abuse.ch/export/txt/'
    ];
    
    let data = null;
    let endpointUsed = '';
    
    for (const endpoint of endpoints) {
      try {
        console.log(`Trying endpoint: ${endpoint}`);
        const response = await fetch(endpoint);
        
        if (response.ok) {
          data = await response.text();
          endpointUsed = endpoint;
          console.log(`Success with endpoint: ${endpoint}`);
          break;
        }
      } catch (err) {
        console.log(`Failed with endpoint: ${endpoint}`, err.message);
        continue;
      }
    }
    
    if (!data) {
      throw new Error('All MalwareBazaar endpoints failed');
    }
    
    // Parse the data from MalwareBazaar
    const lines = data.trim().split('\n');
    
    // Find the header line (skip comment lines starting with #)
    let headerLineIndex = 0;
    for (let i = 0; i < lines.length; i++) {
      if (!lines[i].startsWith('#')) {
        headerLineIndex = i;
        break;
      }
    }
    
    const headers = lines[headerLineIndex].split(',');
    
    console.log(`Headers found: ${headers.join(', ')}`);
    
    // Skip the header line and process malware samples
    const malwareSamples = lines.slice(headerLineIndex + 1).map((line, index) => {
      const values = line.split(',');
      const sample = {};
      
      headers.forEach((header, i) => {
        sample[header] = values[i] || '';
      });
      
      // Transform MalwareBazaar data to our format using actual fields
      const signature = sample['signature'] || sample['tags'] || '';
      const fileType = sample['type'] || sample['file_type'] || '';
      const tags = sample['tags'] || '';
      const dateAdded = sample['date'] || sample['first_seen'] || '';
      const sha256 = sample['sha256'] || sample['sha256_hash'] || '';
      
      return {
        id: `mb-${index}`,
        name: `${fileType ? fileType.toUpperCase() : 'EXE'}_${sha256.substring(0, 8)}.${fileType || 'exe'}`,
        type: mapMalwareType(fileType),
        size: parseInt(sample['file_size'] || sample['size']) || Math.floor(Math.random() * 10000000) + 10000,
        entropy: parseFloat(sample['entropy']) || (Math.random() * 8 + 0.5),
        threatLevel: calculateThreatLevel(signature, tags, parseFloat(sample['entropy']) || 0),
        detectionRate: Math.random() * 100, // MalwareBazaar doesn't provide detection rate
        family: signature || 'Unknown',
        timestamp: dateAdded ? new Date(dateAdded) : new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000),
        signatures: signature ? [signature] : ['Unknown'],
        behavior: extractBehaviors(signature, tags),
        sha256: sha256,
        md5: sample['md5'] || sample['md5_hash'] || '',
        fileType: fileType,
        platform: getPlatformFromType(fileType),
        tags: tags ? tags.split(',').map(tag => tag.trim()) : [],
        dateAdded: dateAdded
      };
    }).filter(sample => sample.name && sample.name !== 'file_name' && sample.name !== 'filename' && !sample.name.startsWith('#')); // Filter out invalid entries
    
    // Limit to 50 samples for performance
    const limitedSamples = malwareSamples.slice(0, 50);
    
    console.log(`Processed ${limitedSamples.length} malware samples`);
    
    res.status(200).json({
      success: true,
      data: limitedSamples,
      count: limitedSamples.length,
      source: 'MalwareBazaar',
      endpoint: endpointUsed
    });
    
  } catch (error) {
    console.error('Error fetching malware data:', error);
    
    // Fallback to generated data if API fails
    const fallbackData = generateFallbackData();
    
    res.status(200).json({
      success: false,
      message: 'Using fallback data due to API error: ' + error.message,
      data: fallbackData,
      count: fallbackData.length,
      source: 'Generated'
    });
  }
};

function mapMalwareType(fileType) {
  const type = fileType.toLowerCase();
  if (type.includes('exe') || type.includes('dll')) return 'trojan';
  if (type.includes('elf')) return 'backdoor'; // Linux malware often backdoors
  if (type.includes('doc') || type.includes('pdf')) return 'spyware';
  if (type.includes('js') || type.includes('vbs')) return 'virus';
  if (type.includes('zip') || type.includes('rar')) return 'backdoor';
  if (type.includes('apk')) return 'trojan'; // Android malware
  return ['trojan', 'ransomware', 'spyware', 'virus', 'worm', 'backdoor'][Math.floor(Math.random() * 6)];
}

function getPlatformFromType(fileType) {
  const type = fileType.toLowerCase();
  if (type.includes('exe') || type.includes('dll')) return 'Windows';
  if (type.includes('elf')) return 'Linux';
  if (type.includes('apk')) return 'Android';
  if (type.includes('dmg')) return 'macOS';
  if (type.includes('js') || type.includes('vbs')) return 'Cross-platform';
  return 'Unknown';
}

function calculateThreatLevel(signature, tags, entropy) {
  const sig = signature.toLowerCase();
  const tagStr = tags.toLowerCase();
  const ent = parseFloat(entropy) || 0;
  
  // Known dangerous families from MalwareBazaar
  if (ent > 7.5 || sig.includes('mirai') || sig.includes('xworm') || sig.includes('snakekeylogger')) {
    return 'critical';
  }
  if (ent > 6.5 || sig.includes('trojan') || sig.includes('backdoor') || tagStr.includes('mirai')) {
    return 'high';
  }
  if (ent > 5.0 || sig.includes('spyware') || sig.includes('keylogger') || tagStr.includes('elf')) {
    return 'medium';
  }
  return 'low';
}

function extractBehaviors(signature, tags) {
  const behaviors = [];
  const sig = signature.toLowerCase();
  const tagStr = tags.toLowerCase();
  
  // Extract behaviors from MalwareBazaar signatures and tags
  if (sig.includes('keylogger') || tagStr.includes('keylogger')) behaviors.push('Keylogging');
  if (sig.includes('mirai') || tagStr.includes('mirai')) behaviors.push('DDoS Attack');
  if (sig.includes('xworm') || tagStr.includes('xworm')) behaviors.push('Remote Access');
  if (sig.includes('snake') || tagStr.includes('snake')) behaviors.push('Data Exfiltration');
  if (sig.includes('elf') || tagStr.includes('elf')) behaviors.push('Linux Exploitation');
  if (sig.includes('exe') || tagStr.includes('exe')) behaviors.push('Windows Exploitation');
  if (sig.includes('backdoor') || tagStr.includes('backdoor')) behaviors.push('Backdoor Access');
  if (sig.includes('trojan') || tagStr.includes('trojan')) behaviors.push('Trojan Activity');
  
  // Add some common behaviors if none found
  if (behaviors.length === 0) {
    const allBehaviors = [
      'Network Scanning', 'Privilege Escalation', 'Persistence', 'Anti-analysis',
      'File Encryption', 'Data Exfiltration', 'Keylogging', 'Screen Capture'
    ];
    behaviors.push(...allBehaviors.slice(0, Math.floor(Math.random() * 3) + 1));
  }
  
  return behaviors;
}

function generateFallbackData() {
  const types = ['trojan', 'ransomware', 'spyware', 'virus', 'worm', 'backdoor'];
  const families = ['Zeus', 'WannaCry', 'Emotet', 'TrickBot', 'Ryuk', 'Dridex', 'Lokibot'];
  const behaviors = [
    'File encryption', 'Data exfiltration', 'Keylogging', 'Screen capture',
    'Network scanning', 'Privilege escalation', 'Persistence', 'Anti-analysis'
  ];
  const signatures = [
    'Trojan.Win32.Generic', 'Ransom.WannaCry', 'Spyware.Keylogger',
    'Virus.Win32.Generic', 'Worm.Network', 'Backdoor.Remote'
  ];

  return Array.from({ length: 50 }, (_, i) => ({
    id: `fallback-${i}`,
    name: `EXE_${Math.random().toString(36).substr(2, 8)}.exe`,
    type: types[Math.floor(Math.random() * types.length)],
    size: Math.floor(Math.random() * 10000000) + 10000,
    entropy: Math.random() * 8 + 0.5,
    threatLevel: ['low', 'medium', 'high', 'critical'][Math.floor(Math.random() * 4)],
    detectionRate: Math.random() * 100,
    family: families[Math.floor(Math.random() * families.length)],
    timestamp: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000),
    signatures: [signatures[Math.floor(Math.random() * signatures.length)]],
    behavior: behaviors.slice(0, Math.floor(Math.random() * 4) + 1),
    sha256: '',
    md5: '',
    fileType: 'exe',
    platform: 'Windows',
    tags: ['exe', 'windows'],
    dateAdded: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]
  }));
} 