const fetch = require('node-fetch');

module.exports = async (req, res) => {
  // Enable CORS
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  try {
    // Try different MalwareBazaar API endpoints
    const endpoints = [
      'https://bazaar.abuse.ch/export/csv/recent/',
      'https://bazaar.abuse.ch/export/csv/',
      'https://bazaar.abuse.ch/export/txt/recent/',
      'https://bazaar.abuse.ch/export/txt/'
    ];
    
    let data = null;
    let endpointUsed = '';
    
    for (const endpoint of endpoints) {
      try {
        console.log(`Trying endpoint: ${endpoint}`);
        const response = await fetch(endpoint);
        
        if (response.ok) {
          data = await response.text();
          endpointUsed = endpoint;
          console.log(`Success with endpoint: ${endpoint}`);
          break;
        }
      } catch (err) {
        console.log(`Failed with endpoint: ${endpoint}`, err.message);
        continue;
      }
    }
    
    if (!data) {
      throw new Error('All MalwareBazaar endpoints failed');
    }
    
    // Parse the data from MalwareBazaar
    const lines = data.trim().split('\n');
    
    // Find the header line (skip comment lines starting with #)
    let headerLineIndex = 0;
    for (let i = 0; i < lines.length; i++) {
      if (!lines[i].startsWith('#')) {
        headerLineIndex = i;
        break;
      }
    }
    
    const headers = lines[headerLineIndex].split(',');
    
    console.log(`Headers found: ${headers.join(', ')}`);
    
    // Skip the header line and process malware samples
    const malwareSamples = lines.slice(headerLineIndex + 1).map((line, index) => {
      const values = line.split(',');
      const sample = {};
      
      headers.forEach((header, i) => {
        sample[header] = values[i] || '';
      });
      
      // Transform MalwareBazaar data to our format
      return {
        id: `mb-${index}`,
        name: sample['file_name'] || sample['filename'] || `malware_${Math.random().toString(36).substr(2, 8)}.exe`,
        type: mapMalwareType(sample['file_type'] || sample['type'] || ''),
        size: parseInt(sample['file_size'] || sample['size']) || Math.floor(Math.random() * 10000000) + 10000,
        entropy: parseFloat(sample['entropy']) || (Math.random() * 8 + 0.5),
        threatLevel: calculateThreatLevel(sample['signature'] || sample['tags'] || '', sample['entropy'] || 0),
        detectionRate: Math.random() * 100, // MalwareBazaar doesn't provide detection rate
        family: sample['signature'] || sample['tags'] || 'Unknown',
        timestamp: new Date(sample['first_seen'] || sample['date'] || Date.now()),
        signatures: [sample['signature'] || sample['tags'] || 'Unknown'],
        behavior: extractBehaviors(sample['signature'] || sample['tags'] || ''),
        sha256: sample['sha256_hash'] || sample['sha256'] || '',
        md5: sample['md5_hash'] || sample['md5'] || '',
        fileType: sample['file_type'] || sample['type'] || 'Unknown',
        platform: sample['platform'] || 'Unknown'
      };
    }).filter(sample => sample.name && sample.name !== 'file_name' && sample.name !== 'filename' && !sample.name.startsWith('#')); // Filter out invalid entries
    
    // Limit to 50 samples for performance
    const limitedSamples = malwareSamples.slice(0, 50);
    
    console.log(`Processed ${limitedSamples.length} malware samples`);
    
    res.status(200).json({
      success: true,
      data: limitedSamples,
      count: limitedSamples.length,
      source: 'MalwareBazaar',
      endpoint: endpointUsed
    });
    
  } catch (error) {
    console.error('Error fetching malware data:', error);
    
    // Fallback to generated data if API fails
    const fallbackData = generateFallbackData();
    
    res.status(200).json({
      success: false,
      message: 'Using fallback data due to API error: ' + error.message,
      data: fallbackData,
      count: fallbackData.length,
      source: 'Generated'
    });
  }
};

function mapMalwareType(fileType) {
  const type = fileType.toLowerCase();
  if (type.includes('exe') || type.includes('dll')) return 'trojan';
  if (type.includes('doc') || type.includes('pdf')) return 'spyware';
  if (type.includes('js') || type.includes('vbs')) return 'virus';
  if (type.includes('zip') || type.includes('rar')) return 'backdoor';
  return ['trojan', 'ransomware', 'spyware', 'virus', 'worm', 'backdoor'][Math.floor(Math.random() * 6)];
}

function calculateThreatLevel(signature, entropy) {
  const sig = signature.toLowerCase();
  const ent = parseFloat(entropy) || 0;
  
  // High entropy or known dangerous families
  if (ent > 7.5 || sig.includes('ransomware') || sig.includes('cryptolocker')) {
    return 'critical';
  }
  if (ent > 6.5 || sig.includes('trojan') || sig.includes('backdoor')) {
    return 'high';
  }
  if (ent > 5.0 || sig.includes('spyware') || sig.includes('keylogger')) {
    return 'medium';
  }
  return 'low';
}

function extractBehaviors(signature) {
  const behaviors = [];
  const sig = signature.toLowerCase();
  
  if (sig.includes('keylogger')) behaviors.push('Keylogging');
  if (sig.includes('screen')) behaviors.push('Screen capture');
  if (sig.includes('network')) behaviors.push('Network scanning');
  if (sig.includes('encrypt')) behaviors.push('File encryption');
  if (sig.includes('exfiltrate')) behaviors.push('Data exfiltration');
  if (sig.includes('persistence')) behaviors.push('Persistence');
  if (sig.includes('privilege')) behaviors.push('Privilege escalation');
  
  // Add some random behaviors if none found
  if (behaviors.length === 0) {
    const allBehaviors = [
      'File encryption', 'Data exfiltration', 'Keylogging', 'Screen capture',
      'Network scanning', 'Privilege escalation', 'Persistence', 'Anti-analysis'
    ];
    behaviors.push(...allBehaviors.slice(0, Math.floor(Math.random() * 3) + 1));
  }
  
  return behaviors;
}

function generateFallbackData() {
  const types = ['trojan', 'ransomware', 'spyware', 'virus', 'worm', 'backdoor'];
  const families = ['Zeus', 'WannaCry', 'Emotet', 'TrickBot', 'Ryuk', 'Dridex', 'Lokibot'];
  const behaviors = [
    'File encryption', 'Data exfiltration', 'Keylogging', 'Screen capture',
    'Network scanning', 'Privilege escalation', 'Persistence', 'Anti-analysis'
  ];
  const signatures = [
    'Trojan.Win32.Generic', 'Ransom.WannaCry', 'Spyware.Keylogger',
    'Virus.Win32.Generic', 'Worm.Network', 'Backdoor.Remote'
  ];

  return Array.from({ length: 50 }, (_, i) => ({
    id: `fallback-${i}`,
    name: `malware_${Math.random().toString(36).substr(2, 8)}.exe`,
    type: types[Math.floor(Math.random() * types.length)],
    size: Math.floor(Math.random() * 10000000) + 10000,
    entropy: Math.random() * 8 + 0.5,
    threatLevel: ['low', 'medium', 'high', 'critical'][Math.floor(Math.random() * 4)],
    detectionRate: Math.random() * 100,
    family: families[Math.floor(Math.random() * families.length)],
    timestamp: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000),
    signatures: [signatures[Math.floor(Math.random() * signatures.length)]],
    behavior: behaviors.slice(0, Math.floor(Math.random() * 4) + 1),
    sha256: '',
    md5: '',
    fileType: 'exe',
    platform: 'Windows'
  }));
} 